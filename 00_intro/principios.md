---
layout: default
title: Princípios de Engenharia de Software
---

## O que é afinal programar bem?

Programar é especificar um processo com precisão utilizando uma linguagem bem definida, de forma a que o mesmo possa ser interpretado por um computador. Porém, boa programação não trata só de especificação, i.e. dizer o que a máquina tem que fazer, mas involve também em boa medida estruturação. O subtítulo deste livro “abstração, decomposição, reutilização” é uma resposta sucinta para o que significa programar bem, independentemente, claro está, do facto de escrever programas sem defeitos (vulgarmente referido na como bug). Estas três palavras são também o  mote para a forma como todo o conteúdo é apresentado neste livro. Em desenvolvimento de software estas três atividades são essenciais para garantir uma eficiente gestão da complexidade e da evolução dos sistemas. Por exemplo, um defeito num programa é obviamente indesejável. Porém, erros toda a gente os comete, mesmo os melhores, e há que saber viver com essa realidade. O problema mais grave é que um defeito idêntico ou semelhante replicado em várias partes do código, resultante de uma má estruturação, poderá consumir muito tempo para resolver por completo. Por outro lado, um defeito cuja funcionalidade em questão está localizada num só sítio será à partida facilmente corrigido de forma fiável uma vez localizado.

*Abstração* é uma operação intelectual que consiste em isolar um elemento à exclusão de outros. Esta capacidade é seguramente uma das mais importantes no desenvolvimento de software, tanto a nível funcional como arquitetural. Decomposição é a capacidade de separar um elemento complexo em partes mais simples. Para decompor adequadamente é necessário abstrair. A atividade de decompor consiste num catalisador para a Reutilização, permitindo que um elemento sejam utilizado diversas vezes em contextos diferentes. Por outro lado, para reutilizar de forma eficiente é preciso abstrair o que se pretende reutilizar de forma objetiva. Estas três atividades, abstrair, decompor, e reutilizar, são fáceis de motivar, porém são difíceis de fazer bem no contexto de programação. Os bons programadores serão competentes nestas três valências, as quais adquiriram provavelmente com muita prática e experiência. Contudo, os materiais didáticos existentes tipicamente não os abordam deliberadamente, nomeadamente nos exemplos, exercícios propostos, e na forma como os conceitos são apresentados. A explicação de conceitos e exercícios propostos deste livro ao longo dos vários capítulos foram concebidos com vista a estimular a abstração, a decomposição, e a reutilização. Relacionados com estas atividades, há princípios subjacentes ao desenvolvimento de software que se devem ter sempre em conta, independentemente do tipo de sistema ou linguagem de programação utilizada. Esses princípios refletem-se também transversalmente ao longo deste livro, e resumem-se nas seguintes máximas:


**Código é para pessoas lerem.** Os computadores apenas compreendem código-máquina, ou por outras palavras, “zeros e uns” que codificam digitalmente as instruções a executar. Contudo, humanamente é impossível codificar os programas de hoje em dia escrevendo código máquina. O papel de uma linguagem de programação (tal como o Java ou outra) é fornecer uma forma de descrever programas que é compreensível por humanos, descrições essas que são transformadas automaticamente em código-máquina (compilação). Conclusão: o computador não precisa de linguagens de programação, estas existem por causa das pessoas. Desta forma, o código é escrito para pessoas lerem, não para a máquina, e logo, os aspetos de compreensão de código devem assumir uma prioridade elevada.

**Código reflete a estrutura do problema que se pretende resolver.** Porque é que se desenvolve software? Para resolver um problema, o qual pode ter uma natureza que vai desde gestão contabilística até pilotagem automática de automóveis. Em todo o caso, os problemas do mundo real são interpretados por pessoas de modo a poderem ser transpostos para um programa. Contudo, há infinitos programas possíveis para resolver o mesmo problema, os quais variam em eficiência, mas também em compreensão. À partida, os programas mais fáceis de compreender (claro está, por pessoas) serão os que reflectem de forma mais próxima o problema que resolvem, por oposição aos programas que incluem diversas indireções no caminho entre problema e solução.

**Problemas complexos são decompostos em sub-problemas.** A mente humana tem limitações, todos o sabemos. Ao passo que um problema simples pode ser abordado de forma direta, um mais complexo irá ser mais difícil dada o esforço cognitivo exigido (ainda que seja possível). O problema é que ao nos aproximarmos do nosso limite cognitivo a propensão para erros aumenta. 1036 / 4 não é uma conta difícil, mas ao tentar fazê-la de cabeça será mais fácil pensar em 1000/4 + 36/4, porque estas duas divisões são mais facéis de fazer de cabeça, bem como 250 + 9 = 259. A decomposição em tarefas mais pequenas ajuda-nos a abordar o problema e a gerir a sua complexidade, e assim acontece também na escrita de software. Ao tentar abordar um problema complexo sem o decompor, não só poderá ser mais difícil resolve-lo, como o código resultante poderá ser mais difícil de compreender e reutilizar.

**Reutilizar é palavra de ordem.** Se precisarmos de pregar um prego, podemos tentar fazê-lo à mão, comprar um martelo, ou fabricar o nosso próprio martelo. A primeira hipótese terá problemas no sucesso da tarefa, para além do tempo e sacrifício exigido. A segunda hipótese tem um custo, e obriga a perceber como usar o martelo comprado, mas depois de pregar muitos pregos com o mesmo martelo, certamente que valerá a pena. Quanto à terceira hipótese, dado que não será trivial fabricar um martelo, e que o mesmo pode não ficar bem feito, só será justificável caso os martelos existentes não se adequem ao tipo de prego em questão (situação pouco provável). Com o software a situação é parecida, pois a bem da eficiência, fiabilidade, e compreensão, torna-se necessário evitar a todo o custo “reinventar a roda”, isto é, (re-)desenvolver código para um problema que já foi resolvido.

**Duplicação (de código) é um mal maior a combater.**  No seguimento do ponto anterior, que promove a reutilização de artefactos de software existentes,  é também importante não duplicar partes de um programa internamente. Isto é, cada pedaço de funcionalidade deve estar num e num só sítio, pois a duplicação do mesmo em várias partes do programa irá favorecer uma manutenção mais difícil do mesmo, abrindo também a porta à degradação  (próximo ponto).
Para além da economização de esforço ao não duplicar, tratar de aspetos do programa num só sítio traz uma grande vantagem em termos de manutenção, tal como na caso da correção de defeitos mencionado atrás. Se uma regra de negócio (por exemplo, a fórmula de cálculo de determinada taxa) estiver espalhada por várias partes do código de um programa, a sua alteração será mais custosa do que se estivesse num só sítio.

**A degradação de software previne-se.** Qual a diferença entre software e hardware? O hardware degrada-se, se não for mantido. Quer isto dizer indiretamente que o problema do software é que a sua manutenção (modificações para acrescentar ou alterar funcionalidade) é que é a causadora da sua degradação. Esta afirmação parece contraditória, mas não o é. Sendo o software maleável e de fácil alteração, ao contrário de um objeto físico, faz com que a um programa bem sucedido e duradouro lhe sejam propostas alterações e adaptações após a sua conceção, pois os problemas do mundo real que o mesmo aborda também mudam e evolvem. E é essencialmente aqui que a degradação acontece dado que muitas vezes a necessidade de adaptação não foi antecipada e a alteração resultante não é feita em linha com o inicialmente concebido. E já que falámos em martelos, este fenómeno é conhecido na gíria informática como “martelada” (para que a coisa funcione, ainda que o arranjo possa não ser o mais correto). Desta forma, torna-se necessário prevenir a degradação de software, o que por vezes passa por antecipar a necessidade de mudança e fazer reestruturações internas para integrar as mesmas.
